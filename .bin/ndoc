#!/usr/bin/env node
'use strict';

var exec = require('child_process').exec;
var Util = require('../lib/util');
var NDoc = require('../lib');


//
// parse options
//
var opts = require('nomnom')
  .option('path', {
    position: 0,
    list: true,
    required: true,
    help: 'Source files location',
    metavar: 'PATH',
  })
  .option('extension', {
    abbr: 'e',
    help: 'Source files extension [js]',
    metavar: 'STRING',
    default: 'js',
  })
  .option('output', {
    abbr: 'o',
    help: 'Resulting file(s) location [doc]',
    metavar: 'PATH',
    default: 'doc',
  })
  .option('format', {
    abbr: 'f',
    help: 'Documentation format [html]',
    choices: ['html', 'json', 'js'],
    metavar: '<html|json|js>',
    default: 'html',
  })
  .option('index', {
    abbr: 'i',
    help: 'Index file [README.md]',
    metavar: 'FILE',
    default: 'README.md',
  })
  .option('packageJson', {
    full: 'package-json',
    help: 'Package description file [package.json]',
    metavar: 'FILE',
    default: 'package.json',
  })
  .option('packageName', {
    full: 'package-name',
    help: 'Package name',
    metavar: 'STRING',
  })
  .option('packageVersion', {
    full: 'package-version',
    help: 'Package version',
    metavar: 'STRING',
  })
  .option('packageTitle', {
    full: 'package-title',
    help: 'Package title',
    metavar: 'STRING',
  })
  .option('linkFormat', {
    abbr: 'l',
    full: 'link-format',
    help: 'Format for link to source file [{file}#L{line}]',
    default: '../{file}#L{line}',
    metavar: 'FMT',
  })
  .option('skin', {
    help: 'Custom templates [' + __dirname + '/../skins/default' + ']',
    default: Util.join(__dirname, '..', 'skins', 'default'),
    metavar: 'PATH',
  })
  .option('viewSourceLabel', {
    full: 'view-source-label',
    help: 'Text for "View source" link',
    metavar: 'STRING',
  })
  .parse();

//
// read missing data from package.json, if any
//
try {
  var package_json = JSON.parse(Util.read(opts.packageJson));
  opts.packageName = opts.packageName || package_json.name || '';
  opts.packageVersion = opts.packageVersion || package_json.version || '';
  opts.packageUrl = opts.packageUrl || (package_json.repository && package_json.repository.url || package_json.repository) || '';
  opts.packageUrl = opts.packageUrl.replace('git://', 'https://').replace(/(\.git$|$)/, '/blob/master');
  opts.packageTitle = opts.packageTitle || package_json.description || opts.packageName || '';
} catch(err) {}

//
// read index file
//
try {
  opts.index = Util.read(opts.index);
} catch(err) {
  opts.index = '';
}

//console.error(opts); process.exit(0);

//
// collect sources
//
var files = [];
Util.walk_many(opts.path, '\.' + opts.extension + '$', function(filename, stat, cb) {
  //console.log('Processing', filename);
  files.push(filename);
  cb();
}, function(err) {
  if (err) {
    console.error(err.message || err);
    process.exit(1);
  }
  // build tree
  var ndoc = new NDoc(files, {
    // given package URL, file name and line in the file, format link to source file
    formatLink: function(file, line) {
      return Util.normalize(opts.linkFormat
        .replace(/\{url\}/g, opts.packageUrl || '')
        .replace(/\{file\}/g, file)
        .replace(/\{line\}/g, line)
      );
    }
  });
  //console.log(ndoc.toJSON());

  // output tree
  var output = opts.output;
  switch (opts.format) {

    case 'json':
      Util.write(output, ndoc.toJSON(opts));
      break;

    case 'js':
      Util.write(output, 'var ndoc = ' + ndoc.toJSON(opts) + ';');
      break;

    case 'html':
      Util.copy(Util.join(opts.skin, 'skeleton'), output, function(err) {
        if (err) {
          console.error(err.message || err);
          process.exit(1);
        }
        var html = ndoc.toHTML(opts);
        Util.write(Util.join(output, 'index.html'), html);
      });
      break;

    default:
      console.error(opts.format + ': not supported')
      process.exit(1);

  }
});
