'use strict';

var Util = require('./util');

//
// export ndoc
//
module.exports = NDoc;

//
// create and load parser
//
try {
  var parser = require('./parser');
} catch(err) {
  (function(){
  var Jison = require('jison');
  var grammar = require('jison/lib/jison/bnf').parse(Util.read(Util.join(__dirname, 'parser.y')));
  Util.write(Util.join(__dirname, 'parser.js'), (new Jison.Parser(grammar)).generate());
  })();
  var parser = require('./parser');
}

//
// helpers
//
function extend(o, plus) {
  var r = {};
  for (var i in o) r[i] = o[i];
  if (plus) for (var i in plus) r[i] = plus[i];
  return r;
}

//
// read source files and compose the documentation tree
//
function NDoc(files, options) {

  // options
  this.options = extend({
  }, options)

  // documentation tree consists of sections, which are populated with documents
  var sections = {
    '': {
      id: 'Default',
      type: 'section',
      children: []
    } // default section
  };
  var list = {};

  // parse specified source files
  files.forEach(function(file) {
    console.log('Compiling file', file);

    // parse file
    try {
      var text = Util.read(file);
      // TODO: consider amending failing document inplace.
      // Say, if it doesn't parse, insert a fake '*' line at failing `line` and retry
      if (false) try {
        var ndocs = parser.parse(text);
      } catch(err) {
        err.message.replace(/.*Parse error on line (\d+):.*/, function(all, line) {
          line = Number(line);
          console.error('Chpok at', line, text.split('\n')[line]);
        });
      }
      var ndocs = parser.parse(text);
      // do pre-distribute early work
      for (var id in ndocs) {
        var d = ndocs[id];
        // FIXME: reconcile id clashes. E.g. prototype has 'Ajax' section and 'Ajax' namespace
        /***if (sections[d.id]) {
          console.error('ID clash: id=%s, new type=%s, old type=%s', id);
        }***/
        // assign hierarchy helpers
        d.aliases = [];
        d.children = [];
        if (d.type === 'class') {
          //d.superclass = null;
          d.subclasses = [];
        }
        // collect sections
        if (d.type === 'section') {
          sections[d.id] = d;
        // collect flat list
        } else {
          list[(d.section || '') + '.' + d.id] = d;
        }
        // compose links to source files
        d.href = options.formatLink(file, d.line);
      }
    } catch(err) {
      console.error('FATAL:', file, err.message || err);
      process.exit(1);
    }
  });

  // distribute by sections
  for (var id in list) {
    sections[list[id].section || ''].children.push(id);
  }

  // sort children, to help building hierarchy
  var t = [];
  for (var section in sections) {
    sections[section].children = sections[section].children.sort();
    t = t.concat(sections[section].children);
  }

  // for each document with undefined section try to guess the section
  // E.g. for ".Ajax.Updater" we try to find "SECTION.Ajax" element.
  // If found, rename ".Ajax.Updater" to "SECTION.Ajax.Updater"
  var parted = t.map(function(id) {
    return id.split(/[.#]/);
  });
  var len = parted.length;
  for (var idx = 0; idx < len; ++idx) {
    if (parted[idx][0] !== '') continue;
    for (var i = idx + 1; i < len; ++i) {
      if (parted[idx][1] === parted[i][1] && parted[i][0] !== '') {
        var p = t[idx];
        // prefix with guessed section
        t[idx] = parted[i][0] + t[idx];
        // update flat list element, since key and value's id has been changed
        var g = list[p];
        delete list[p];
        g.id = p = t[idx];
        list[p] = g;
        break;
      }
    }
  }

  var tree = {};
  t = t.sort();
  t.forEach(function(id) {
    tree[id] = list[id];
  });

  // rebuild the tree from the end to beginning.
  // N.B. since the list we iterate over is sorted, we can determine precisely
  // the parent of any element.
  for (var i = t.length; --i >= 1; ) {
    var id = t[i];
    var pid = id.substring(0, Math.max(id.lastIndexOf('.'), id.lastIndexOf('#')));
    //console.log('MOVE: [%s] to [%s]?', id, pid);
    var p = tree[pid];
    if (!p) continue;
    p.children.unshift(tree[id]);
    delete tree[id];
    //console.log('MOVED: [%s] to [%s]!', id, pid);
  }

if (false) {

  // move from '' section to named sections
  for (var section in sections) {
    if (section === '') continue;
    // sort definitions, to help building hierarchy
    //var children = sections[section].children.sort(function(a,b){return a.id === b.id ? 0 : a.id < b.id ? -1 : 1});
    //var children = sections[section].children.sort();
    for (var id in sections[section].children) {
      var re = new RegExp('^' + id + '[#.]');
      for (var cid in sections[''].children) {
         if (sections[''].children[cid].match(re)) {
           sections[section].children[cid] = cid;
           delete sections[''].children[cid];
         }
      }
    }
  }

  // re-sort children for each section
  for (var section in sections) {
    var ids = Object.keys(sections[section].children).sort();
    var nids = ids.length;
    sections[section].children = {};
    // build hierarchy
    // N.B. Foo#a is child of Foo
    // N.B. since we've sorted keys, Foo always comes before Foo#a
    for (var i = 0; i < nids; ++i) {
      var elem = list[ids[i]];
      elem.section = section;
      var re = new RegExp('^' + ids[i] + '[#.]');
      for (var j = i + 1; j < nids; ++j) {
        if (ids[j].match(re)) {
          var p = list[ids[j]].parent;
          if (p && list[p]) {
            delete list[p].children[ids[j]];
          }
          list[ids[j]].parent = ids[i];
          elem.children[ids[j]] = ids[j];
        }
      }
      sections[section].children[elem.id] = elem;
    }
  }

  // remove children from high level
  // FIXME: should be recursive?
  /***for (var section in sections) {
    for (var id in sections[section].children) {
      var d = sections[section].children[id];
      //if (d.parent && !(d.type === 'namespace' || d.type === 'class' || d.type === '')) {
      if (d.parent) {
        //delete sections[section].children[id];
      }
    }
  }***/

  // distribute methods and properties
  for (var id in list) {
    var d = list[id];

    // convert children hash to array
    d.children = Object.keys(d.children).map(function(id) {
      return list[id];
    });

    // aliases
    if (d.alias_of && list[d.alias_of]) {
      list[d.alias_of].aliases.push(d.id);
    }

    // classes hierarchy
    if (d.type === 'class') {
      if (d.superclass && list[d.superclass]) {
        list[d.superclass].subclasses.push(d.id);
      }
    // methods and properties
    } else if (d.type === 'method' || d.type === 'property') {
      if ((~d.id.indexOf('#'))) {
        d.type = 'instance ' + d.type;
        if (d.parent && d.bound) {
          d.functionalized_self = d.parent;
        }
      } else if ((~d.id.indexOf('.'))) {
        d.type = 'class ' + d.type;
        if (d.bound) {
          d.methodized_self = d.id;
        }
      } else {
        d.type = 'utility';
      }
    }

    // short names and paths
    if (d.type === 'namespace' || d.type === 'class' || d.type === 'mixin') {
      d.name = d.id.replace(/^.*[.]/, '');
      d.path = d.id;
    } else if (d.type === 'constructor') {
      d.name = 'new';
      d.path = d.parent + '/new';
    } else if (~d.type.indexOf('class ') || d.type === 'constant') {
      d.name = d.id.replace(/^.*[.]/, '');
      d.path = d.parent + '/' + d.name;
    } else if (~d.type.indexOf('instance ') || d.type === 'constant') {
      d.name = d.id.replace(/^.*[#]/, '');
      d.path = d.parent + '/prototype/' + d.name;
    } else if (d.type === 'utility') {
      d.name = d.id;
      d.path = d.name;
    } else {
      throw 'Unknown document type: ' + d.type;
    }
    d.path = d.section + '/' + d.path;

  }

  for (section in sections) {
    var d = sections[section];
    d.name = d.id;
    d.path = d.id;
    // convert children hash to array
    d.children = Object.keys(d.children).map(function(id) {
      return list[id];
    });
  }

}

  this.sections = sections;
  this.list = list;
  this.tree = tree;
}

NDoc.prototype.toJSON = function(options) {
  var list = {};
  for (var id in this.list) {
    var d = this.list[id];
    list[id] = {
      id: d.id,
      type: d.type,
      name: d.name,
      path: d.path,
      parent: d.parent,
      section: d.section,
    };
  }
  return JSON.stringify({
    //list: list,
    //sections: this.sections,
    tree: this.tree,
    /*packageName: options.packageName,
    packageVersion: options.packageVersion,
    date: (new Date).toUTCString(),
    readme: options.index,
    src_code_text: options.viewSourceLabel,
    src_code_href: options.linkFormat,*/
  });
};

NDoc.prototype.toHTML = function(options) {

  var Jade = require('jade');
  var md2html = require('marked');
  //var md2html = require('robotskirt').toHtmlSync;

  var path = Util.join(options.skin, 'templates', 'layout.jade');
  var str = Util.read(path);
  var fn = Jade.compile(str, {
    filename: path,
    //pretty: false
  });

  var sections = this.sections;
  var list = this.list;

  for (var i in list) {
    var obj = list[i];
    // path should be HTML valid id
    obj.path = obj.path.replace(/\//g, '-');
  }

  function link(obj, short, classes) {
    if (typeof obj === 'string') obj = list[obj] || {id: obj, name: obj, path: obj, type: ''};
    var r = '<a href="#' + obj.path + '" class="' + (classes||[]).join(' ') + '" title="' + obj.id + ' (' + obj.type + ')" data-id="' + obj.id + '">';
    r += short ? obj.name : obj.id;
    r += '</a>';
    return r;
  }

  // convert markdown to HTML
  function markdown(text) {
    if (text == null) console.error('NULL');
    //if (!text) text = '@@@EMPTY@@@';
    //var r = ''+md2html(text);
    var r = md2html(text);
    return r;
  }

  // given signature object, recompose its textual representation
  // FIXME: move to templates?
  function signature(obj, sig) {
    if (typeof obj === 'string') obj = list[obj];
    var r = obj.id;
    if (sig.args) {
      r += '(';
      sig.args.forEach(function(arg, idx, args) {
        var a = arg.name;
        if (obj.bound && !idx) a = '@' + a;
        if (arg.default_value) a = a + ' = ' + arg.default_value;
        if (idx) a = ', ' + a;
        if (arg.ellipsis) a += '...';
        if (arg.optional) a = '[' + a + ']';
        r += a;
      });
      r += ')';
    }
    return r;
  }

  var vars = {
    list: this.list,
    sections: this.sections,
    packageName: options.packageName,
    packageVersion: options.packageVersion,
    date: (new Date).toUTCString(),
    readme: options.index,
    src_code_text: options.viewSourceLabel,
    src_code_href: options.linkFormat,
    link: link,
    markdown: markdown,
    signature: signature
  };

  var html = fn(vars);
  return html;
};
