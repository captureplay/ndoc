mixin menu()
  for obj in tree
    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
      mixin menu_item(obj, 0)

mixin menu_item(obj, level, short)
  if typeof obj === 'string'
    obj = tree[obj]
  li
    .menu-item
      a(class=[obj.type.replace(/ /g, '-'), obj.deprecated && 'deprecated', obj.chainable && 'chainable', obj.internal && 'internal', obj.readonly && 'readonly'].filter(function(x){return !!x;}), href='##{obj.path}', title='#{obj.id} (#{obj.type})', 'data-id'=obj.id) #{short && obj.name || obj.id}
      if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
        if obj.children.length
          ul.hidden
            for child in obj.children
              mixin menu_item(child, level + 1, true)


//- way difficult to style. put on standby so far
  mixin signature(obj, sig)
    if sig.args
      ul.args
        for arg in sig.args
          a = arg.name
          c = []
          -if (obj.bound) c.push('arg-bound')
          if arg.default_value
            a = a + ' = ' + arg.default_value
          -if (arg.ellipsis) c.push('arg-ellipsis')
          -if (arg.optional) c.push('arg-optional');
          li.arg(class=c)
            = a
    if sig.returns
      ul.returns
        for ret in sig.returns
          li.ret
            = (ret || '?')


mixin argument(arg)
  li.argument
    ul.argument-details
      li.argument-name= arg.name
      if arg.types
        li.argument-types
          ul
            for type, i in arg.types
              li.argument-type= type
      if arg.description
        li.argument-description
          mixin markdown(arg.description)


mixin title(obj)
  header

    //- breadcrumbs

    ul.breadcrumbs
      li
        a(href='#home') Home
      breadcrumbs = []
      x = obj
      - while (x) { breadcrumbs.unshift(x); x = x.parent && tree[x.parent]; }
      for crumb in breadcrumbs
        li
          mixin link(crumb, true)

    h2
      span.type #{obj.type}
      span.name #{obj.id}

    if obj.href
      .source
        a(href=obj.href)
          = src_code_text || 'View source code'


mixin article(obj)
  if typeof obj === 'string'
    obj = tree[obj]

  article.article(id=obj.path, class=[obj.deprecated && 'deprecated'].filter(function(x){return !!x;}))

    mixin title(obj)

    if obj.deprecated && obj.deprecated.since
      .deprecated-note
        | Deprecated since
        = obj.deprecated.since
        if obj.deprecated.off
          | &nbsp;and will be removed on #{obj.deprecated.off}

    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'

      if obj.description
        .section.description
          h3 Description
          .content
            mixin markdown(obj.description)

      if obj.namespaces.length
        .section.namespaces
          h3 Namespaces
          .content
            mixin short_description_list(obj.namespaces)

      if obj.classes.length
        .section.classes
          h3 Classes
          .content
            mixin short_description_list(obj.classes)

      if obj.mixins.length
        .section.mixins
          h3 Mixins
          .content
            mixin short_description_list(obj.mixins)

      if obj.type === 'class'

        if obj.superclass
          .section.superclass
            h3 Superclass
            .content
              mixin link(obj.superclass)

        if obj.subclasses.length
          .section.subclasses
            h3 Subclasses
            .content
              mixin links(obj.subclasses.sort())

      if obj.included_mixins
        .section.mixins
          h3 Includes
          .content
            mixin links(obj.included_mixins.sort())

      if obj.utilities.length
        .section.classes
          h3 Related utilities
          .content
            mixin links(obj.utilities.sort())

      if tree['new ' + obj.id]
        .section.constructor
          h3 Constructor
          .content
          ul.method-list
            mixin link_list('new ' + obj.id)

      for title, method in {class_methods: 'Class methods', class_properties: 'Class properties', instance_methods: 'Instance methods', instance_properties: 'Instance properties', constants: 'Constants'}
        methods = obj[method]
        if Object.keys(methods).length
          .section(class='#{method}')
            h3 #{title}
            .content
              ul.method-list
                for x in methods
                  mixin link_list(x)

    else

      .section.method(class=[obj.chainable && 'chainable', obj.internal && 'internal', obj.readonly && 'readonly'].filter(function(x){return !!x;}))
        .content
          if obj.signatures
            ul.signatures
              for sig in obj.signatures
                li.signature
                  ul
                    li.signature-call
                      != signature(obj, sig)
                    if sig.returns
                      li.signature-returns
                        ul.argument-types
                          for type in sig.returns
                            li.argument-type= (type || '?')

          if obj.arguments
            ul.argument-list
              for arg in obj.arguments
                mixin argument(arg)

          mixin markdown(obj.description)
          if obj.methodized_self
            p.note.
              This method can be called <em>either</em> as an
              a(href=obj.methodized_self) instance method
              <em>or</em> as a generic method.
              If calling as generic, pass the instance in as the first argument. 
          else if obj.functionalized_self
            p.note.
              This method can be called <em>either</em> as an instance method <em>or</em> as a
              a(href=obj.functionalized_self) generic method.
              If calling as generic, pass the instance in as the first argument. 

    if obj.aliases.length
      .alias.aliases
        | Aliased as:
        ul.aliases
          for alias in obj.aliases
            li.alias
              mixin link(alias)

    if obj.alias_of
      .alias.alias-of
        | Alias of:
        ul.aliases
          li.alias
            mixin link(obj.alias_of)

    if obj.related_to && obj.related_to
      .related-to
        | Related to:
        mixin link(obj.related_to)


  if obj.children.length
    for child in obj.children
      mixin article(child)



mixin api(tree)
  for obj in tree
    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
      mixin article(obj)



mixin short_description_list(collection)
  ul.method-details-list
    for obj in collection
      li.method-description
        h4
          a(href=obj.path) #{obj.id}
        if obj.short_description
          p= obj.short_description


mixin link(obj, short, classes)
  != link(obj, short, classes)

mixin markdown(text, inline)
  html = markdown(text)
  if inline
    //- FIXME: can't be done via CSS? The point is to compensate for <p>
    html = html.slice(3, -4)
  //- desugar [[foo#bar]] tokens into local links
  - html = html.replace(/\[\[(.+?)\]\]/g, function(all, id) { return link(id, true, ['link-short']); });
  != html



mixin links(collection)
  ul
    for obj in collection
      li
        mixin link(obj)

mixin link_list(obj)
  if typeof obj === 'string'
    obj = tree[obj]
  li
    mixin link(obj)
