mixin menu()
  for obj in tree
    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
      mixin menu_item(obj, 0)

mixin menu_item(obj, level, short)
  if typeof obj === 'string'
    obj = tree[obj]
  li
    .menu-item
      a(class=[obj.type.replace(/ /g, '-')].join(' '), href='##{obj.path}', title='#{obj.id} (#{obj.type})', 'data-id'=obj.id) #{short && obj.name || obj.id}
      if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
        if obj.children.length
          ul.hidden
            for child in obj.children
              mixin menu_item(child, level + 1, true)



//-
  mixin signature(obj, sig)
    r = obj.id
    if sig.args
      r += '('
      sig.args.forEach(function(arg, idx, args) {
        var a = arg.name;
        if (obj.bound && !idx) a = '@' + a;
        if (a.default_value) a = a + ' = ' + a.default_value;
        if (idx) a = ', ' + a;
        if (arg.ellipsis) a += '...';
        if (arg.optional) a = '[' + a + ']';
        r += a;
      })
      r += ')'
    if sig.returns
      r += ' &rarr; ' + sig.returns.join(' | ')
    = r


mixin argument(arg)
  li
    ul.argument
      li.argument-name= arg.name
      if arg.types
        ul.argument-types
          for type, i in arg.types
            li.argument-type= type
      if arg.description
        li.argument-description
          != markdown(arg.description).slice(3, -4)

mixin returns(sig)
  for r in sig.returns
    if tree[r]
      mixin link(r)
    else
      = r


mixin title(obj)
  header

    //- breadcrumbs

    ul.breadcrumbs
      li
        a(href='#home') Home
      breadcrumbs = []
      x = obj
      - while (x) { breadcrumbs.unshift(x); x = x.parent && tree[x.parent]; }
      for crumb in breadcrumbs
        li
          mixin link(crumb, true)

    h2
      span.type #{obj.type}
      span.name #{obj.id}

    if obj.href
      .source
        a(href=obj.href)
          = src_code_text || 'View source code'

    if obj.deprecated
      #deprecated
        img(src='images/deprecated.png', alt='Deprecated', width=150, height=150)
      if obj.deprecated.since
        h2
          | Deprecated since
          =obj.deprecated.since
          if obj.deprecated.off
            = 'and will be removed on #{obj.deprecated.off}'


mixin article(obj)
  if typeof obj === 'string'
    obj = tree[obj]

  article.article(id=obj.path)

    mixin title(obj)

    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'

      if obj.description
        .section.description
          h3 Description
          .content
            != markdown(obj.description)

      if obj.namespaces.length
        .section.namespaces
          h3 Namespaces
          .content
            mixin short_description_list(obj.namespaces)

      if obj.classes.length
        .section.classes
          h3 Classes
          .content
            mixin short_description_list(obj.classes)

      if obj.mixins.length
        .section.mixins
          h3 Mixins
          .content
            mixin short_description_list(obj.mixins)

      if obj.type === 'class'

        if obj.superclass
          .section.superclass
            h3 Superclass
            .content
              p= obj.superclass

        if obj.subclasses.length
          .section.subclasses
            h3 Subclasses
            .content
              p
                mixin links(obj.subclasses.sort())

      if obj.included_mixins
        .section.mixins
          h3 Includes
          .content
            mixin links(obj.included_mixins.sort())

      if obj.utilities.length
        .section.classes
          h3 Related utilities
          .content
            mixin links(obj.utilities.sort())

      if tree['new ' + obj.id]
        .section.constructor
          h3 Constructor
          .content
          ul.method-list
            mixin link_list('new ' + obj.id)

      for title, method in {class_methods: 'Class methods', class_properties: 'Class properties', instance_methods: 'Instance methods', instance_properties: 'Instance properties', constants: 'Constants'}
        methods = obj[method]
        if Object.keys(methods).length
          .section(class='#{method}')
            h3 #{title}
            .content
              ul.method-list
                for x in methods
                  mixin link_list(x)

    else

      .section.method(class=[obj.chainable && 'chainable', obj.internal && 'internal', obj.readonly && 'readonly'].filter(function(x){return !!x;}))
        .content
          if obj.signatures
            ul.signature
              for sig in obj.signatures
                li
                  != signature(obj, sig)
                  //-mixin signature(obj, sig)

          if obj.arguments
            ul.argument-list
              for arg in obj.arguments
                mixin argument(arg)

          != markdown(obj.description)
          if obj.methodized_self
            p.note.
              This method can be called <em>either</em> as an
              a(href=obj.methodized_self) instance method
              <em>or</em> as a generic method.
              If calling as generic, pass the instance in as the first argument. 
          else if obj.functionalized_self
            p.note.
              This method can be called <em>either</em> as an instance method <em>or</em> as a
              a(href=obj.functionalized_self) generic method.
              If calling as generic, pass the instance in as the first argument. 

    if obj.aliases.length
      .alias.aliases
        | Aliased as:
        for alias in obj.aliases
          mixin link(alias)

    if obj.alias_of
      .alias.alias-of
        | Alias of:
        mixin link(obj.alias_of)

    if obj.related_to && obj.related_to
      .related-to
        | Related to:
        mixin link(obj.related_to)


  if obj.children.length
    for child in obj.children
      mixin article(child)



mixin api(tree)
  for obj in tree
    if obj.type === 'namespace' || obj.type === 'class' || obj.type === 'mixin'
      mixin article(obj)



mixin short_description_list(collection)
  ul.method-details-list
    for obj in collection
      li.method-description
        h4
          a(href=obj.path) #{obj.id}
        if obj.short_description
          p= obj.short_description

mixin link(obj, short)
  //- != link(obj, short)
  if typeof obj === 'string'
    obj = tree[obj] || {id: obj, path: obj, type: ''}
  a(href="##{obj.path}", title="#{obj.id} (#{obj.type})", 'data-id'=obj.id)
    if short
      = obj.name
    else
      = obj.id

mixin links(collection)
  ul
    for obj in collection
      li
        mixin link(obj)

mixin link_list(obj)
  if typeof obj === 'string'
    obj = tree[obj]
  li
    mixin link(obj)
